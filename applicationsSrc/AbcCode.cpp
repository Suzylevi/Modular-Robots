/**
 * @file AbcCode.cpp
 * Generated by VisibleSim BlockCode Generator
 * https://services-stgi.pu-pm.univ-fcomte.fr/visiblesim/generator.php#
 * @author yourName
 * @date 2022-09-20
 **/
#include "AbcCode.hpp"

BlinkyBlocksBlock *moduleA=nullptr;
BlinkyBlocksBlock *moduleB=nullptr;
BlinkyBlocksBlock *moduleC=nullptr;
BlinkyBlocksBlock *moduleCenter=nullptr;
int distAB=0,distBC=0,distBcenter=0,distCcenter=0;


AbcCode::AbcCode(BlinkyBlocksBlock *host):BlinkyBlocksBlockCode(host),module(host) {
    if (not host) return;

    addMessageEventFunc2(GO_MSG_ID_A,std::bind(&AbcCode::ElectAfunc,this,std::placeholders::_1, std::placeholders::_2));
    addMessageEventFunc2(BACK_MSG_ID_A,std::bind(&AbcCode::AGradfunc,this,std::placeholders::_1, std::placeholders::_2));
    addMessageEventFunc2(LIGHT_MSG_ID_A,std::bind(&AbcCode::ABackfunc,this,std::placeholders::_1, std::placeholders::_2));

    addMessageEventFunc2(GO_MSG_ID_B,std::bind(&AbcCode::ElectBfunc,this,std::placeholders::_1, std::placeholders::_2));
    addMessageEventFunc2(BACK_MSG_ID_B,std::bind(&AbcCode::BGradientfunc,this,std::placeholders::_1, std::placeholders::_2));
    addMessageEventFunc2(LIGHT_MSG_ID_B,std::bind(&AbcCode::BBackfunc,this,std::placeholders::_1, std::placeholders::_2));

    addMessageEventFunc2(LIGHT_MSG_ID_C,std::bind(&AbcCode::ElectCfunc,this,std::placeholders::_1, std::placeholders::_2));

}

void AbcCode::startup() {
    console << "start " << getId() << "\n";
    myDistance=10000;
    myParent=nullptr;
    myLongestChildDist=0;
    myLongestChild=nullptr;

    myDistanceB=10000;
    myParentB=nullptr;
    myLongestChildDistB=0;
    myLongestChildB=nullptr;

    if (isA) {
        isA=true;
        setColor(RED);
        moduleA=module;
        myNbWaitedAnswer=sendMessageToAllNeighbors("go",new MessageOf<int>(GO_MSG_ID_A,1), 100, 1000, 0);
    }
    
}

void AbcCode::ElectAfunc(std::shared_ptr<Message> _msg, P2PNetworkInterface *sender) {
    MessageOf<int>* msg = static_cast<MessageOf<int>*>(_msg.get());
    int msgData = *msg->getData();

    console << "rcv " << msgData << " from " << sender->getConnectedBlockBId() << "\n";
    if (myParent == nullptr) {
        myDistance = msgData;
        myParent = sender;
        myNbWaitedAnswer = sendMessageToAllNeighbors("go",
                                  new MessageOf<int>(GO_MSG_ID_A, msgData + 1), 100, 1000, 1, sender);
        if (myNbWaitedAnswer == 0) {
            sendMessage("back", new MessageOf<int>(BACK_MSG_ID_A, myDistance), myParent, 100, 1000);
        }
    } else {
        sendMessage("back", new MessageOf<int>(BACK_MSG_ID_A, -1), sender, 100, 1000);
    }
}
void AbcCode::AGradfunc(std::shared_ptr<Message> _msg, P2PNetworkInterface *sender) {
    MessageOf<int>* msg = static_cast<MessageOf<int>*>(_msg.get());
    int msgData = *msg->getData();
    console << "rcv ACK " << msgData << " from " << sender->getConnectedBlockBId() << "\n";

    if (msgData > myLongestChildDist) {
        myLongestChildDist = msgData;
        myLongestChild = sender;
    }

    myNbWaitedAnswer--;
    if (myNbWaitedAnswer == 0) {
        if (myParent) {
            sendMessage("back", new MessageOf<int>(BACK_MSG_ID_A, max(myLongestChildDist, myDistance)), myParent, 100, 1000);
        } else { 
            setColor(RED);
            sendMessage("Light", new Message(LIGHT_MSG_ID_A), myLongestChild, 100, 0);
        }
    }
}
void AbcCode::ABackfunc(std::shared_ptr<Message> _msg, P2PNetworkInterface *sender) {
    if (myLongestChild) {
        sendMessage("Light", new Message(LIGHT_MSG_ID_A), myLongestChild, 100, 0);
    } else {
        setColor(GREEN);
        moduleB = module;
        distAB = myDistance;
        isB=true;
        myNbWaitedAnswerB=sendMessageToAllNeighbors("go",new MessageOf<int>(GO_MSG_ID_B,1), 100, 1000, 0);
    }
}

void AbcCode::ElectBfunc(std::shared_ptr<Message> _msg, P2PNetworkInterface *sender) {
    MessageOf<int>* msg = static_cast<MessageOf<int>*>(_msg.get());
    int msgData = *msg->getData();

    console << "rcv " << msgData << " from " << sender->getConnectedBlockBId() << "\n";
    if (myParentB == nullptr) {
        myDistanceB = msgData;
        myParentB = sender;
        myNbWaitedAnswerB = sendMessageToAllNeighbors("go",
                                  new MessageOf<int>(GO_MSG_ID_B, msgData + 1), 100, 1000, 1, sender);
        if (myNbWaitedAnswerB == 0) {
            sendMessage("back", new MessageOf<int>(BACK_MSG_ID_B, myDistanceB), myParentB, 100, 1000);
        }
    } else {
        sendMessage("back", new MessageOf<int>(BACK_MSG_ID_B, -1), sender, 100, 1000);
    }
}
void AbcCode::BGradientfunc(std::shared_ptr<Message> _msg, P2PNetworkInterface *sender) {
    MessageOf<int>* msg = static_cast<MessageOf<int>*>(_msg.get());
    int msgData = *msg->getData();
    console << "rcv ACK " << msgData << " from " << sender->getConnectedBlockBId() << "\n";

    if (msgData > myLongestChildDistB) {
        myLongestChildDistB = msgData;
        myLongestChildB = sender;
    }

    myNbWaitedAnswerB--;
    if (myNbWaitedAnswerB == 0) {
        if (myParentB) {
            sendMessage("back", new MessageOf<int>(BACK_MSG_ID_B, max(myLongestChildDistB, myDistanceB)), myParentB, 100, 1000);
        } else { 
            setColor(YELLOW);
            sendMessage("Light", new Message(LIGHT_MSG_ID_B), myLongestChildB, 100, 0);
        }
    }
}
void AbcCode::BBackfunc(std::shared_ptr<Message> _msg, P2PNetworkInterface *sender) {
    if (myLongestChildB) {
        sendMessage("Light", new Message(LIGHT_MSG_ID_B), myLongestChildB, 100, 0);
    } else {
        setColor(BLUE);
        moduleC = module;
        isC=true;
        distBC = myDistanceB;
        sendMessage("Light", new Message(LIGHT_MSG_ID_C), myParentB, 100, 0);


    }
}

void AbcCode::ElectCfunc(std::shared_ptr<Message> _msg, P2PNetworkInterface *sender) {
    if (myLongestChildB && myDistanceB==distBC/2) {
        setColor(BROWN);
        moduleCenter = module;
        distBcenter = distCcenter= myDistanceB;
    } else {
        sendMessage("Light", new Message(LIGHT_MSG_ID_C), myParentB, 100, 0);
    }
}

void AbcCode::parseUserBlockElements(TiXmlElement *config) {
  

    const char *attr = config->Attribute("isA");
    if (attr!=nullptr) {
        std::cout << getId() << " is leader!" << std::endl; // complete with your code
        isA=true;
    }
}
string AbcCode::onInterfaceDraw() {
    string str="Press 'r' to run the simulation.";
    if (moduleA!= nullptr) {
        str="A= ("+moduleA->position.to_string()+")";
      }
    if (moduleB!=nullptr) {
        str+="\nB= ("+moduleB->position.to_string()+"), distAB="+ to_string(distAB);
    }
    if (moduleC!=nullptr) {
        str+="\nC= ("+moduleC->position.to_string()+"), distBC="+ to_string(distBC);
    }
    /*if (moduleCenter!=nullptr) {
        str+="\nCenter= ("+moduleCenter->position.to_string()+"), dist to B="+
             to_string(distBcenter)+", dist to C="+ to_string(distCcenter);
    }*/
    return str;
}
